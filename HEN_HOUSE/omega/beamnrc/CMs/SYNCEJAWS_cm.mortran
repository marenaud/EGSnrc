%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: synchronized dynamic jaws                 "
"  Copyright (C) 2018 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Marc-Andre Renaud, 2018                                   "
"                                                                             "
"  Based on SYNCJAWS by Tony Popescu and Julio Lobo                           "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the existing BEAMnrc JAWS component  "
"  module and contributed back to NRC by the authors in 2010. It was rebased  "
"  on the DYNJAWS component module by Blake Walters in 2013.                  "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************      ""toc:
"                             *            *      ""toc:
"                             * SYNCEJAWS  *      ""toc:
"                             *            *      ""toc:
"                             **************      ""toc:
"
"   Programmer:  George Ding.
"
"   Development  Version, begun September 5, 1992. Completed in October,1992
"
"   For complete history see sccs record.
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.
"   Set of paired bars.(collimator jaws or applicator)
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   paired bars. The bas are of arbitrary thickness and material,and X or Y.
"   orintation.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
%E   "SYNCEJAWS_cm.mortran - start of geometry description
"I>
"I> Geometry of SYNCEJAWS:                             ""toc:
"I> ******************
"I>                                  ||
"I>                                \ || /   beam
"I>                                 \||/
"I>                                  \/
"I>
"I>             ---------------------------------------------------
"I>
"I>             -------------     IR=1      ----------------
"I>                         /              |
"I>  ISCM=1       IR=3     /               |   IR=2
"I>            ------------  - - - - - - -  -----------------
"I>
"I>           ---------------    IR=4     ---------------------
"I>                         /            \
"I>  ISCM=2       IR=6     /              \  IR=5
"I>       ----------------- - - - - - - -  -----------------------
"I>
"I>
"I>   IR is the region number within the CM.  There are N_SYNCEJAWS local
"I>   regions. The first region is between bars or jaws.  An air gap is
"I>   always present at the front.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            | IRSTART_$SYNCEJAWS |  IR_SYNCEJAWS  | see graph       |
"I>            |   +IR_SYNCEJAWS-1 |           |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_$SYNCEJAWS
"                      ISUMRY_$SYNCEJAWS
"                      HOWFAR_$SYNCEJAWS
"                      WHERE_AM_I_$SYNCEJAWS
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                   Description of Users Input from Unit 5   ""toc:
"                   **************************************
"
"I>
"I>  CARDS CM_$SYNCEJAWS
"I>  **************
"I>
"I>  -1  dummy line read in main used to separate input for CMs
"I>
"I>   0  RMAX_CM(ICM_$SYNCEJAWS) (F10.0):
"I>                         Perpendicular distance from Z-axis to boundary
"I>                         surrounding component module.  This component
"I>                         module has a square boundary.
"I>
"I>   1  TITLE_$SYNCEJAWS (60A1):  Title of CM.
"I>
"I>   2  ISCM_MAX_$SYNCEJAWS, MODE_$SYNCEJAWS (2I5)
"I>
"I>           ISCM_MAX_$SYNCEJAWS = Number of paired bars or jaws in CM.
"I>               MODE_$SYNCEJAWS = 0 for static settings of jaw openings
"I>                            1 for dynamic settings with simulated
"I>                              jaw movement while beam is on
"I>                            2 for step-and-shoot jaw movement--beam
"I>                              off while jaw settings are changed
"I>
"I>   Repeat 3 (if MODE_$SYNCEJAWS=1,2) or 3 and 4 (if MODE_$SYNCEJAWS=0)
"I>               for I=1,ISCM_MAX_$SYNCEJAWS
"I>
"I>   3  XY_CHOICE (A1):  indicate orientation of the paired bars/jaws
"I>                        X means bars/jaws perpendicular to x axis
"I>                       i.e. separation and movement is along x-axis
"I>
"I>   4  ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I),ZRAD_$SYNCEJAWS(I),
"I>      RAD_$SYNCEJAWS(I) (4F15.0)
"I>
"I>   Next input is only required if MODE_$SYNCEJAWS=0 (static)
"I>
"I>   5  XP_$SYNCEJAWS(I),XN_$SYNCEJAWS(I) (2F15.0)
"I>
"I>        XP_$SYNCEJAWS(I):  positive bar/jaw x or y coodinate.
"I>        XN_$SYNCEJAWS(I):  negative bar/jaw x or y coodinate.
"I>
"I>   Next input is only required if MODE_$SYNCEJAWS=1 or 2
"I>
"I>   5a jaws_file (A256)
"I>
"I>        jaws_file: The full name of a file containing jaw opening data
"I>                   in the following format:
"I>
"I>      NFIELDS_$SYNCEJAWS (I10)
"I>      FOR J=1,NFIELDS_$SYNCEJAWS[
"I>        INDEX_$SYNCEJAWS(J) (F15.0)
"I>        (XP_$SYNCEJAWS(I),XN_$SYNCEJAWS(I), I=1,ISCM_MAX_$SYNCEJAWS)
"I>      ]
"I>
"I>      where:
"I>
"I>      NFIELDS_$SYNCEJAWS:  Total number of jaw settings.
"I>      INDEX_$SYNCEJAWS(J):  Index of setting J. 0 <= INDEX_$SYNCEJAWS(J) <= 1
"I>                         and INDEX_$SYNCEJAWS(J) > INDEX_$SYNCEJAWS(J-1).
"I>			    This
"I>                         number is compared to a random number on [0,1] at
"I>                         the start of each history; if the random number is
"I>                         <= INDEX_$SYNCEJAWS(J), then, if MODE_$SYNCEJAWS=2,
"I>                         settings J are used.  If MODE_$SYNCEJAWS=1, then
"I>                         the settings used are a linear interpolation
"I>                         between fields J-1 and J based on the random
"I>                         number selected.  See manual for more details.
"I>      XP_$SYNCEJAWS(I),XN_$SYNCEJAWS(I):
"I>                         See description of input 5.  These are defined
"I>                         for each field, J.
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE, IREGION_to_BIT (2F15.0,2I5): for interior
"I>                                                     (assumed to be AIR)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:      Dose scoring zone of air surrounding bars.
"I>          IREGION_TO_BIT: This region associated with this bit in LATCH
"I>
"I>   Repeat 6 and 7 for I=1,ISCM_MAX_$SYNCEJAWS
"I>
"I>   7   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT (2F15.0,2I5)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons in
"I>                          jaw I.
"I>          DOSE_ZONE:      Dose scoring zone for jaw I.
"I>          IREGION_TO_BIT: Both bars of jaw I associated with this bit.
"I>
"I>   8   MED_IN (24A1):  Medium of jaw I, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following input defines a single tungsten jaw oriented in the Y
"I>  direction operating in step-and-shoot (MODE_$SYNCEJAWS=2) mode.
"I>  The jaw settings (Z position, opening coordinates) are defined
"I>  in the file $OMEGA_HOME/beamnrc/CMs/dynjaw.opening.file
"I>  (included with the distribution).
"I>
"I>  45, RMAX
"I>  SYNCEJAW settings
"I>  2, 0, # PAIRED BARS OR JAWS, field type
"I>  X
"I>  4.0, 13.5,
"I>  0.5, 8.2, -17.5, 17.5
"I>  Y
"I>  11.7, 13.5,
"I>  8.3, 15.7, -17.5, 17.5,
"I>  0.7, 0.01, 0, 0,
"I>  0.7, 0.01, 0, 0,
"I>  W700ICRU
"I>  0.7, 0.01, 0, 0,
"I>  W700ICRU

"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping bars not allowed
"
"   3)  Air gap at front of CM required
"
"   4)  Inner boundary of all bars must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E   "Start of subroutine HOWFAR_$SYNCEJAWS "
"*******************************************************************************
"************************** Component Module SYNCEJAWS *************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_SYNCEJAWS
"                          ***********************
"
" HOWFAR routine for set of paired bars.
"
" Determine if current region number is within component module SYNCEJAWS, and
" if so evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.
"
"   There are 4xISCM local regions see above graph:
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_$SYNCEJAWS)+IRL-1               IRL
"
"   Geometrical co-ordinates, as set in INPUT_SYNCEJAWS are:
"
"   ZFRONT_SYNCEJAWS     front of CM (upstream surface, air region)
"   ZBACK_SYNCEJAWS      back of CM (downstream surface, air region)
"   ZMIN_SYNCEJAWS(IRL)  front of bars ISCM,
"   ZMAX_SYNCEJAWS(IRL)  back of bars ISCM
"
"*******************************************************************************
;SUBROUTINE HOWFAR_$SYNCEJAWS;


;IMPLICIT NONE;
;COMIN/CMs,CM_$SYNCEJAWS,EPCONT,STACK,USER,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_SYNCEJAWS
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro"
   IB_$SYNCEJAWS,    "T>index to deal with round off errors"
   I_tpo,I_tne, "T>error indices"
   IRNEW_$SYNCEJAWS; "T>tentative new region number within CM (absolute)"

$REAL
   DIST,       "T>distance to region boundary along current particle trajectory"
   DIST1,      "T>holds value of DIST while further checks are done"
   XPLN_$SYNCEJAWS,  "T>X or Y at a plane surface along particle trajectory"
   ZPLN_$SYNCEJAWS,  "T>Z along particle trajectory"
   DXY_$SYNCEJAWS,
   DZ_$SYNCEJAWS,
   DELTA_$SYNCEJAWS,
   RCHECK_$SYNCEJAWS,
   XNEDGE_$SYNCEJAWS, "T>X/Y coord of edge of negative jaw"
   XPEDGE_$SYNCEJAWS, "T>X/Y coord of edge of positive jaw"
   RPLN_$SYNCEJAWS;  "T>Distance between particle and jaw radius curvature"

DATA I_tpo,I_tne/0,0/;

IRL = IR(NP); "local region number (absolute)"
"
" This replacement macros sets DNEAR as well as defining IR_$SYNCEJAWS,
 ;$SYNCEJAWS_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check 
" ***********************
"
" Determine if current region number is within component module SYNCEJAWS, and
" if so evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.
""
";$SYNCEJAWS_SET_XY_UV(ISCM_$SYNCEJAWS);"" needed if no dnear caln in howfar"
IF(IR_$SYNCEJAWS = 3*ISCM_$SYNCEJAWS-2) [
  " Particle not in positive or negative bar. "
  IB_$SYNCEJAWS=1;

  IF(W(NP) > 0.0) [
    IF(Z(NP) < ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL) [
      DIST = (ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) - Z(NP) + $BDY_TOL) / W(NP);

      XPLN_$SYNCEJAWS = XY_$SYNCEJAWS + UV_$SYNCEJAWS * DIST;
      ZPLN_$SYNCEJAWS = Z(NP) + DIST*W(NP);
      XPEDGE_$SYNCEJAWS = XP_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                          + ROUNDMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;
      XNEDGE_$SYNCEJAWS = XN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                          - ROUNDMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;

      IF (XPLN_$SYNCEJAWS > XPEDGE_$SYNCEJAWS) [
        " Going in positive bar "
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 1;
      ]
      ELSEIF (XPLN_$SYNCEJAWS < XNEDGE_$SYNCEJAWS) [
        " Going in negative bar "
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 2;
      ]
      ELSE [
        " Could be going in the bars through the rounded ends or straight "
        " through the open field. "
        DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP) + $BDY_TOL)/W(NP);
        IF(DIST < 0) [DIST = 0.0;]
        IF(DIST=0. & ISCM_$SYNCEJAWS=ISCM_MAX_$SYNCEJAWS)[DIST=1.E-16;]
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*ISCM_$SYNCEJAWS;
        IF(ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[IRNEW_$SYNCEJAWS =1;]

        $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
        $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

        IF (TPOS_$SYNCEJAWS < DIST & TPOS_$SYNCEJAWS < TNEG_$SYNCEJAWS) [
          " Going through the open field and hitting the positive jaw "
          DIST = TPOS_$SYNCEJAWS;
          IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 1;
        ]
        ELSEIF (TNEG_$SYNCEJAWS < DIST & TNEG_$SYNCEJAWS < TPOS_$SYNCEJAWS) [
          " Going through the open field and hitting the negative jaw "
          DIST = TNEG_$SYNCEJAWS;
          IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 2;
        ]
      ]
    ]
    ELSE [ " Z(NP) > ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) and W(NP) > 0"
      " Could be going in the bars through the rounded ends or straight "
      " through the open field. "
      DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) - Z(NP) + $BDY_TOL)/W(NP);
      IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*ISCM_$SYNCEJAWS;
      IF(ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[IRNEW_$SYNCEJAWS =1;]

      $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
      $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

      IF (TPOS_$SYNCEJAWS < DIST & TPOS_$SYNCEJAWS < TNEG_$SYNCEJAWS) [
        " Going through the open field and hitting the positive jaw "
        DIST = TPOS_$SYNCEJAWS;
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 1;
      ]
      ELSEIF (TNEG_$SYNCEJAWS < DIST & TNEG_$SYNCEJAWS < TPOS_$SYNCEJAWS) [
        " Going through the open field and hitting the negative jaw "
        DIST = TNEG_$SYNCEJAWS;
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 2;
      ]
    ]

    IF(DIST <= USTEP ) [ " particle to be moved to region boundary "
      USTEP = DIST;
      IF (IRNEW_$SYNCEJAWS=1) ["leaving CM through back"
        CALL WHERE_AM_I(ICM_$SYNCEJAWS,1);
      ]
      ELSE ["still in CM, entering between bars"
        IRNEW = IRNEW_$SYNCEJAWS; "new region number"
      ]
    ]
  ] " End of W(NP) > 0.0 "
  ELSEIF (W(NP) < 0.0) [
    IF(Z(NP) < ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL) [
      IF(ISCM_$SYNCEJAWS = 1)[
        DIST = (ZFRONT_$SYNCEJAWS - Z(NP))/W(NP);
        IF(DIST <= 0)[ DIST = 1.E-16;]
        IRNEW_$SYNCEJAWS = 1;
      ]
      ELSE[ "  ISCM_$SYNCEJAWS > 1, means we're going into an upper jaw "
        ;$SYNCEJAWS_SET_XY_UV(ISCM_$SYNCEJAWS-1);

        DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS-1) - Z(NP) + $BDY_TOL) / W(NP);

        XPLN_$SYNCEJAWS = XY_$SYNCEJAWS + UV_$SYNCEJAWS * DIST;
        ZPLN_$SYNCEJAWS = Z(NP) + DIST * W(NP);

        XPEDGE_$SYNCEJAWS = XP_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                            + ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;
        XNEDGE_$SYNCEJAWS = XN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                            - ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;

        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2);

        IF (XPLN_$SYNCEJAWS > XPEDGE_$SYNCEJAWS) [
          " Going in positive bar of above jaw "
          IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2) + 1;
        ]
        ELSEIF (XPLN_$SYNCEJAWS < XNEDGE_$SYNCEJAWS) [
          " Going in negative bar of above jaw "
          IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2) + 2;
        ]
      ]
    ]
    ELSE [ " Z(NP) > ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS) "
      " Could be going in the bars through the rounded ends or straight "
      " through the open field. "
      DIST = (ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP) - $BDY_TOL)/W(NP);
      IF(DIST < 0)[ DIST = 0.0;]

      $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
      $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

      IF (TPOS_$SYNCEJAWS < DIST & TPOS_$SYNCEJAWS < TNEG_$SYNCEJAWS) [
        " Going through the open field and hitting the positive jaw "
        DIST = TPOS_$SYNCEJAWS;
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 1;
      ]
      ELSEIF (TNEG_$SYNCEJAWS < DIST & TNEG_$SYNCEJAWS < TPOS_$SYNCEJAWS) [
        " Going through the open field and hitting the negative jaw "
        DIST = TNEG_$SYNCEJAWS;
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 2;
      ]
      ELSE [
        " Going through the open field without hitting anything "
        IF(ISCM_$SYNCEJAWS = 1)[
          DIST = (ZFRONT_$SYNCEJAWS - Z(NP))/W(NP);
          IF(DIST <= 0)[ DIST = 1.E-16;]
          IRNEW_$SYNCEJAWS = 1;
        ]
        ELSE[ "  ISCM_$SYNCEJAWS > 1, means we're going into an upper jaw "
          ;$SYNCEJAWS_SET_XY_UV(ISCM_$SYNCEJAWS-1);

          DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS-1) - Z(NP) - $BDY_TOL) / W(NP);
          IF(DIST < 0)[ DIST = 0.0;]

          XPLN_$SYNCEJAWS = XY_$SYNCEJAWS + UV_$SYNCEJAWS * DIST;
          ZPLN_$SYNCEJAWS = Z(NP) + DIST * W(NP);
          XPEDGE_$SYNCEJAWS = XP_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                              + ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;
          XNEDGE_$SYNCEJAWS = XN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                              - ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) + $BDY_TOL;

          IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2);
          IF (XPLN_$SYNCEJAWS > XPEDGE_$SYNCEJAWS) [
            " Going in positive bar of above jaw "
            IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2) + 1;
          ]
          ELSEIF (XPLN_$SYNCEJAWS < XNEDGE_$SYNCEJAWS) [
            " Going in negative bar of above jaw "
            IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-2) + 2;
          ]
        ]
      ]
    ]

    IF(DIST <= USTEP ) [
      USTEP = DIST;
      IF(IRNEW_$SYNCEJAWS = 1)["particle moving out from front CM"
        CALL WHERE_AM_I(ICM_$SYNCEJAWS,-1);
      ]
      ELSE[  "still in CM"
        IRNEW = IRNEW_$SYNCEJAWS; "new region number"
      ]
    ]
  ] " End of W(NP) < 0.0 "
  ELSE [ "W(NP) == 0.0"
    DIST=1.0E20;
    IF (Z(NP) > ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS)) [
      IF (UV_$SYNCEJAWS > 0.0) [
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 1;
        $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
        DIST = TPOS_$SYNCEJAWS;
      ]
      ELSE [
        IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1) + 2;
        $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
        DIST = TNEG_$SYNCEJAWS;
      ]
    ]
    IF(DIST <= USTEP) ["particle to be moved to region boundary"
      USTEP = DIST;
      IRNEW = IRNEW_$SYNCEJAWS; "new region number"
    ]
  ]
] " End of region 1 "
ELSEIF (IR_$SYNCEJAWS = 3*ISCM_$SYNCEJAWS-1) [ "particle in positive bars"
  IB_$SYNCEJAWS=2;
  IF(W(NP) > 0.0) [
    " Assume it will hit the bottom face for now "
    IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*ISCM_$SYNCEJAWS;
    IF(ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[IRNEW_$SYNCEJAWS =1;]

    DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP)+$BDY_TOL)/W(NP);
    " Edge case checks copied from SYNCJAWS "
    IF(DIST < 0)[DIST = 0.0;]
    IF(DIST=0. & ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[DIST=1.E-16;]

    $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

    IF(TPOS_$SYNCEJAWS < DIST) [
      DIST = TPOS_$SYNCEJAWS;
      IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);
      IF (DIST < 0) [ DIST = 0.0;]
      IF(DIST=0. & ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[DIST=1.E-16;]
    ]

    IF(DIST <= USTEP) ["particle to be moved to region boundary"
      USTEP = DIST;
      IF (IRNEW_$SYNCEJAWS=1) ["leaving CM through back"
        CALL WHERE_AM_I(ICM_$SYNCEJAWS,1);
      ]
      ELSE ["still in CM, entering between bars"
        IRNEW = IRNEW_$SYNCEJAWS; "new region number"
      ]
    ]
  ] " End of W > 0.0 "
  ELSEIF (W(NP) < 0.0) [ " W < 0.0"
    DIST = (ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP)-$BDY_TOL)/W(NP);
    IF(DIST < 0)[DIST = 0.0;]
    IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);

    $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

    IF (TPOS_$SYNCEJAWS < TZMIN_$SYNCEJAWS) [
      DIST = TPOS_$SYNCEJAWS;
    ]
  ]
  ELSE [ " W == 0 "
    DIST=1.0E20;
    IF(UV_$SYNCEJAWS < 0.0)[
      IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);
      $SYNCEJAWS_FIND_TPOS(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
      DIST = TPOS_$SYNCEJAWS;
    ]
  ]

  IF (DIST <= USTEP) [
    USTEP = DIST;
    IF (IRNEW_$SYNCEJAWS=1) [ "leaving CM through back"
      CALL WHERE_AM_I(ICM_$SYNCEJAWS,1);
    ]
    ELSE [ "still in CM, entering between bars"
      IRNEW = IRNEW_$SYNCEJAWS; "new region number"
    ]
  ]
]
ELSEIF (IR_$SYNCEJAWS = 3 * ISCM_$SYNCEJAWS) [ " Negative bars "
  IB_$SYNCEJAWS = 2;
  IF(W(NP) > 0.0) [
    DIST = (ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP)+$BDY_TOL)/W(NP);
    IF(DIST < 0)[DIST = 0.0;]
    IF(DIST=0. & ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[DIST=1.E-16;]
    IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*ISCM_$SYNCEJAWS;
    IF(ISCM_$SYNCEJAWS = ISCM_MAX_$SYNCEJAWS)[IRNEW_$SYNCEJAWS =1;]

    $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

    IF(TNEG_$SYNCEJAWS < TZMAX_$SYNCEJAWS) [
      DIST = TNEG_$SYNCEJAWS;
      IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);
    ]

    IF(DIST <= USTEP) ["particle to be moved to region boundary"
      USTEP = DIST;
      IF (IRNEW_$SYNCEJAWS=1) ["leaving CM through back"
        CALL WHERE_AM_I(ICM_$SYNCEJAWS,1);
      ]
      ELSE ["still in CM, entering between bars"
        IRNEW = IRNEW_$SYNCEJAWS; "new region number"
      ]
    ]
  ] " End of W > 0.0 "
  ELSEIF (W(NP) < 0.0) [ " W < 0.0"
    DIST = (ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS)-Z(NP)-$BDY_TOL)/W(NP);
    IF(DIST < 0)[DIST = 0.0;]
    IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);

    $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);

    IF (TNEG_$SYNCEJAWS < TZMIN_$SYNCEJAWS) [
      DIST = TNEG_$SYNCEJAWS;
    ]
  ]
  ELSE [ " W == 0 "
    DIST=1.0E20;
    IF(UV_$SYNCEJAWS > 0.0)[
      IRNEW_$SYNCEJAWS = IRSTART_$SYNCEJAWS + 3*(ISCM_$SYNCEJAWS-1);
      $SYNCEJAWS_FIND_TNEG(ISCM_$SYNCEJAWS, IB_$SYNCEJAWS);
      DIST = TNEG_$SYNCEJAWS;
    ]
  ]

  IF (DIST <= USTEP) [
    USTEP = DIST;
    IF (IRNEW_$SYNCEJAWS=1) [ "leaving CM through back"
      CALL WHERE_AM_I(ICM_$SYNCEJAWS,1);
    ]
    ELSE [ "still in CM, entering between bars"
      IRNEW = IRNEW_$SYNCEJAWS; "new region number"
    ]
  ]
]
ELSE [ " Something is wrong! "
  OUTPUT IR(NP)-IRSTART_$SYNCEJAWS+1, IR(NP), ICM_$SYNCEJAWS,
    IR_start_CM(ICM_$SYNCEJAWS);
    (//' ************'//' HOWFAR_SYNCJAWS error'/
       '    Region, local, absolute =',2I5/
       '    CM number=',I5,' start region =',I5/
       ' *********'//);
  STOP;
]
RETURN;
END; " End of subroutine HOWFAR_$SYNCEJAWS "
%E   "Start of subroutine WHERE_AM_I_$SYNCEJAWS "
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SYNCEJAWS
"                          ***************************
"
" WHERE_AM_I routine for set of SYNCEJAWS.
"
" WHERE_AM_I_$SYNCEJAWS determines the new region number when a particle
" traverses a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$SYNCEJAWS subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$SYNCEJAWS from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************
;SUBROUTINE WHERE_AM_I_$SYNCEJAWS(IDIR);


;IMPLICIT NONE;
;COMIN/CM_$SYNCEJAWS,EPCONT,STACK,CMs,USER/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SYNCEJAWS
"T>**************************************
"T>"
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward"
$REAL XBDY_$SYNCEJAWS, XPEDGE_$SYNCEJAWS, XNEDGE_$SYNCEJAWS;
XBDY_$SYNCEJAWS = X(NP) + U(NP)*USTEP;
IF(IXY_CHOICE_$SYNCEJAWS(ISCM_MAX_$SYNCEJAWS) = 1)[
   XBDY_$SYNCEJAWS = Y(NP) + V(NP)*USTEP;
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)"
   "$CHECK_FRONT_$SYNCEJAWS;"
   IRNEW = IRSTART_$SYNCEJAWS;
]
ELSE ["particle entering this CM through back face (downstream)"
  IRNEW = IRSTART_$SYNCEJAWS + 3*ISCM_MAX_$SYNCEJAWS - 3;
  "$CHECK_BACK_$SYNCEJAWS;"
  XPEDGE_$SYNCEJAWS = XP_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                      + ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS);
  XNEDGE_$SYNCEJAWS = XN_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS)
                      - ROUNDMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS);

  IF(XBDY_$SYNCEJAWS > XPEDGE_$SYNCEJAWS)[
    IRNEW = IRSTART_$SYNCEJAWS + 3*ISCM_MAX_$SYNCEJAWS - 2;
  ]
  ELSEIF(XBDY_$SYNCEJAWS < XNEDGE_$SYNCEJAWS)[
    IRNEW = IRSTART_$SYNCEJAWS + 3*ISCM_MAX_$SYNCEJAWS - 1;
  ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_$SYNCEJAWS"
%E   "Start of subroutine INPUT_$SYNCEJAWS "
"*******************************************************************************
"
"                           Subroutine INPUT_SYNCEJAWS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more paired bars.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_$SYNCEJAWS;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_$SYNCEJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SYNCEJAWS
"T>*********************************
"T>"
INTEGER I,J,K,         "T>DO loop indeces"
        IRA,         "T>Absolute region number"
        MED_FLAG,    "T>flag used by media-sort macro $MED_INPUT"
        MED_INDEX,   "T>medium index, set after medium sort by $MED_INPUT"
        jaws_unit,   "T>unit no. for file of dynamic jaws settings"
        egs_get_unit; "T>EGS function to assign unit to jaws_file"

$REAL AIRGAPMIN_$SYNCEJAWS,  "T>minimum air gap in front and back of CM"
      BDYTOL,          "T>stores $BDY_TOL"
      TZMAX;           "T>stores max value of ZMAX (for MODE=1,2)"
CHARACTER*1 XY_CHOICE(1);
character*256 jaws_file;
CHARACTER*80 JAWS_TITLE; "T> title line in file"
"
"  initialize parameters
"  =====================
"
ICM_$SYNCEJAWS = ICM;      "CM index for this component module"
IRSTART_$SYNCEJAWS = IR_start_CM(ICM_$SYNCEJAWS); "Index of first region in this"
                                    "CM set by previous CM or in MAIN if ICM=1"
IERR_GEOM(ICM_$SYNCEJAWS) = 0; "Geometry-checking flag, 0 if no error detected"
AIRGAPMIN_$SYNCEJAWS = 0.01; "Minimum 0.01 cm air gap at front and back of CM"

TZMAX=-999.;

OUTPUT RMAX_CM(ICM); (' This component is sets of paired bars or jaws'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
OUTPUT;(' TITLE: ',$);
;MINPUT ($SYNCEJAWS) TITLE_$SYNCEJAWS;(60A1);
                          ";MINPUT is a replacement macro with EOF and"
                          "ERR branching to :EOF_{P1}: and :ERR_{P1}:"
OUTPUT TITLE_$SYNCEJAWS;(' ',60A1);
IF(ICM_$SYNCEJAWS = 1)[
   OUTPUT;(' This is the first component and starts at the reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_$SYNCEJAWS);(' Previous CM ends at:',F12.5,' cm');]

"
"   get geometry information
"   =============================
"
"get the number of paired bars/jaws"
ISCM_MAX_$SYNCEJAWS = $MAX_N_$SYNCEJAWS; "Max number of paired bars/jaws permitted"
OUTPUT ISCM_MAX_$SYNCEJAWS;
       (' NUMBER OF paired bars/jaws (minimum 1, maximum',I3,'),'/
        ' MODE of JAWS (0--static, 1--dynamic, 2--step-and-shoot)'/
        ' : ',$);
;MINPUT ($SYNCEJAWS) ISCM_MAX_$SYNCEJAWS,MODE_$SYNCEJAWS; (2I5);
OUTPUT ISCM_MAX_$SYNCEJAWS,MODE_$SYNCEJAWS; (2I5);
IF(ISCM_MAX_$SYNCEJAWS > $MAX_N_$SYNCEJAWS)[
   OUTPUT ICM_$SYNCEJAWS, $MAX_N_$SYNCEJAWS;
   (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
      '# of paired bars > max. allowed.'/
      '# of pared bars reduced to ',I4,' for now.'//);
   ISCM_MAX_$SYNCEJAWS=$MAX_N_$SYNCEJAWS;
   IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
]
ELSEIF(ISCM_MAX_$SYNCEJAWS<1)[
   ISCM_MAX_$SYNCEJAWS=1;
   OUTPUT ICM_$SYNCEJAWS;
   (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
      '# of paired bars < 1'/
      '# of pared bars reset to 1 for now.'//);
   IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
]
N_$SYNCEJAWS = 3*ISCM_MAX_$SYNCEJAWS;
IF(MODE_$SYNCEJAWS<0 | MODE_$SYNCEJAWS>2)[
   MODE_$SYNCEJAWS=0;
   OUTPUT;(/' Mode of jaws defaults to 0 (static).'/);
]

"loop over bars"
DO I = 1,ISCM_MAX_$SYNCEJAWS ["loop to get each bar location"
 OUTPUT I;(/' Paired bar/jaw set no:',I3,/
    ' Are bars/jaws perpendicular to x or y axis'/
    ' i.e. is separation measured on x or y axis'/
    ' (Input "y" or "Y" for Y jaws, any other character for X jaws): ',$);
  ;MINPUT ($SYNCEJAWS) XY_CHOICE;(1A1);
  OUTPUT XY_CHOICE;(' ',1A1);
  IXY_CHOICE_$SYNCEJAWS(I) = 0;
  IF(XY_CHOICE(1) ='Y' | XY_CHOICE(1) ='y')[ IXY_CHOICE_$SYNCEJAWS(I) = 1;]
  OUTPUT;(' Input ZRAD, RAD (cm) all on one line');
  ;MINPUT ($SYNCEJAWS) ZRAD_$SYNCEJAWS(I), RAD_$SYNCEJAWS(I);(2F15.0);
  ;OUTPUT ZRAD_$SYNCEJAWS(I), RAD_$SYNCEJAWS(I);(2F11.5);

 IF(MODE_$SYNCEJAWS=0)[
   IF(IXY_CHOICE_$SYNCEJAWS(I) = 0)["this is x bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: XN, XP(cm),',
         ' all on one line');
   ]
   ELSE ["this is y bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: YN, YP(cm),',
         ' all on one line');
   ]
   IF(I=1)[
         OUTPUT AIRGAPMIN_$SYNCEJAWS;
          (' (leave at least min. airgap = ',F8.5,' before 1st jaws)',
          /' : ',$);
   ]
   ELSE[
         OUTPUT AIRGAPMIN_$SYNCEJAWS;
          (' (leave at least min. airgap = ',F8.5,' between jaws)',
           /' : ',$);
   ]

   ;MINPUT ($SYNCEJAWS) ZMIN_$SYNCEJAWS(I), ZMAX_$SYNCEJAWS(I),
      XN_$SYNCEJAWS(I),XP_$SYNCEJAWS(I);(4F15.0);
      ;OUTPUT ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I), XN_$SYNCEJAWS(I),
      XP_$SYNCEJAWS(I);(4F11.5);

   IF(I=1)[
       IF(ICM_$SYNCEJAWS=1 &
         Z_min_CM(ICM_$SYNCEJAWS)>ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS)[
         OUTPUT ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS,
         ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,100)ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS,
              ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS,Z_min_CM(1);
          100 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCEJAWS)>ZMIN_$SYNCEJAWS(1))[
         OUTPUT ICM_$SYNCEJAWS;
           (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
              'Overlaps with previous CM'//);
           IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCEJAWS)>ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS)[
         OUTPUT ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS,
         Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS,
                ZMIN_$SYNCEJAWS(1);
           (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS,
                Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS,ZMIN_$SYNCEJAWS(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_$SYNCEJAWS(1)=Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS;
       ]
   ]
   ELSE[
     IF (ZMAX_$SYNCEJAWS(I-1)>ZMIN_$SYNCEJAWS(I))[
        OUTPUT ICM_$SYNCEJAWS, I-1, I;
         (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
            'Paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
     ]
     ELSEIF (ZMAX_$SYNCEJAWS(I-1)>ZMIN_$SYNCEJAWS(I)-AIRGAPMIN_$SYNCEJAWS)[
        OUTPUT ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS, I-1, I, I,
                ZMAX_$SYNCEJAWS(I-1)+AIRGAPMIN_$SYNCEJAWS,ZMIN_$SYNCEJAWS(I);
          (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,102)ICM_$SYNCEJAWS, AIRGAPMIN_$SYNCEJAWS, I-1, I, I,
                ZMAX_$SYNCEJAWS(I-1)+AIRGAPMIN_$SYNCEJAWS,ZMIN_$SYNCEJAWS(I);
        102 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        ZMIN_$SYNCEJAWS(I)=ZMAX_$SYNCEJAWS(I-1)+AIRGAPMIN_$SYNCEJAWS;
     ]
   ]
   IF(ZMIN_$SYNCEJAWS(I) >= ZMAX_$SYNCEJAWS(I))[
      OUTPUT ICM_$SYNCEJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
   ]
   IF(ABS(XP_$SYNCEJAWS(I) - RAD_$SYNCEJAWS(I))>RMAX_CM(ICM_$SYNCEJAWS))[
      OUTPUT ICM_$SYNCEJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'XP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
   ]
   IF(ABS(XN_$SYNCEJAWS(I) - RAD_$SYNCEJAWS(I))>RMAX_CM(ICM_$SYNCEJAWS))[
      OUTPUT ICM_$SYNCEJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'XN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
   ]
   IF((XP_$SYNCEJAWS(I) - RAD_$SYNCEJAWS(I)) < (XN_$SYNCEJAWS(I)
                                               + RAD_$SYNCEJAWS(I)))[
      OUTPUT ICM_$SYNCEJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'XP(',I4,') - RAD < XN(',I4,') + RAD'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
   ]
   ELSEIF((XP_$SYNCEJAWS(I) - RAD_$SYNCEJAWS(I))
          - (XN_$SYNCEJAWS(I) + RAD_$SYNCEJAWS(I)) < $BDY_TOL*3 )[
      XP_$SYNCEJAWS(I) = XP_$SYNCEJAWS(I) + $BDY_TOL*2;
      XN_$SYNCEJAWS(I) = XN_$SYNCEJAWS(I) - $BDY_TOL*2;
   ]
 ]
] "end of loop over paired bars/jaws"
IF(MODE_$SYNCEJAWS=1 | MODE_$SYNCEJAWS=2)[
  OUTPUT;(/' Input full name of file containing jaw data:'/);
  READ(i_input,'(A256)')jaws_file;
  OUTPUT jaws_file;(A/);
  call replace_env(jaws_file);
  jaws_unit=70;
  jaws_unit=egs_get_unit(jaws_unit);
  IF(jaws_unit<1)[
    $egs_fatal(*,
         'SYNCEJAWS data file: failed to get a free Fortran I/O unit');
  ]
  open(jaws_unit,file=jaws_file,status='old',err=:no-jaws-data-file:);
  read(jaws_unit,'(A80)') JAWS_TITLE;
  read(jaws_unit,'(I10)') NFIELDS_$SYNCEJAWS;

  IF(NFIELDS_$SYNCEJAWS>$MAXFIELD_$SYNCEJAWS) [
   OUTPUT $MAXFIELD_$SYNCEJAWS;
        (/' The number of fields is greater than $MAXFIELD_$SYNCEJAWS: ',I10, /
        ' Increase $MAXFIELD_$SYNCEJAWS in SYNCEJAWS_macros.mortran'/);
   STOP;
  ];

  DO I=1,NFIELDS_$SYNCEJAWS[
  "read in jaw positions for each field"
     read(jaws_unit,'(F15.0)')INDEX_$SYNCEJAWS(I);
     DO J=1,ISCM_MAX_$SYNCEJAWS[
       K=(I-1)*ISCM_MAX_$SYNCEJAWS+J;
       read(jaws_unit,'(4F15.0)')DZMIN_$SYNCEJAWS(K),DZMAX_$SYNCEJAWS(K),
                                 DXN_$SYNCEJAWS(K), DXP_$SYNCEJAWS(K);
       IF(J=1)[
       IF(ICM_$SYNCEJAWS=1 &
         Z_min_CM(ICM_$SYNCEJAWS)>DZMIN_$SYNCEJAWS(K)-AIRGAPMIN_$SYNCEJAWS)[
         OUTPUT ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS,
         DZMIN_$SYNCEJAWS(K)-AIRGAPMIN_$SYNCEJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
            ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
            ' of CM and 1st jaws.'/
            ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,103)ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS,
              DZMIN_$SYNCEJAWS(K)-AIRGAPMIN_$SYNCEJAWS,Z_min_CM(1);
          103 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
           ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$SYNCEJAWS(1)-AIRGAPMIN_$SYNCEJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCEJAWS)>DZMIN_$SYNCEJAWS(K))[
         OUTPUT ICM_$SYNCEJAWS,I;
           (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
              'In field ',I4,' overlaps with previous CM'//);
           IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCEJAWS)>DZMIN_$SYNCEJAWS(K)-AIRGAPMIN_$SYNCEJAWS)[
         OUTPUT ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS,
         Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS,
                DZMIN_$SYNCEJAWS(K);
           (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,104)ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS,
                Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS,DZMIN_$SYNCEJAWS(K);
         104 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         DZMIN_$SYNCEJAWS(K)=Z_min_CM(ICM_$SYNCEJAWS)+AIRGAPMIN_$SYNCEJAWS;
       ]
   ]
   ELSE[
     IF (DZMAX_$SYNCEJAWS(K-1)>DZMIN_$SYNCEJAWS(K))[
        OUTPUT ICM_$SYNCEJAWS, I, J-1, J;
         (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
         'In field ',I4,' paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
     ]
     ELSEIF (DZMAX_$SYNCEJAWS(K-1)>DZMIN_$SYNCEJAWS(K)-AIRGAPMIN_$SYNCEJAWS)[
        OUTPUT ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS,J-1, J, J,
                DZMAX_$SYNCEJAWS(K-1)+AIRGAPMIN_$SYNCEJAWS,DZMIN_$SYNCEJAWS(K);
          (//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,105)ICM_$SYNCEJAWS, I, AIRGAPMIN_$SYNCEJAWS, J-1, J, J,
                DZMAX_$SYNCEJAWS(K-1)+AIRGAPMIN_$SYNCEJAWS,DZMIN_$SYNCEJAWS(K);
        105 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCEJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        DZMIN_$SYNCEJAWS(K)=DZMAX_$SYNCEJAWS(K-1)+AIRGAPMIN_$SYNCEJAWS;
     ]
   ]
   IF(DZMIN_$SYNCEJAWS(K) >= DZMAX_$SYNCEJAWS(K))[
      OUTPUT ICM_$SYNCEJAWS, I, J, J;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'In field ',I4,' ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
   ]
   IF(DZMAX_$SYNCEJAWS(K)>TZMAX) TZMAX=DZMAX_$SYNCEJAWS(K);
       IF(ABS(DXP_$SYNCEJAWS(K))>RMAX_CM(ICM_$SYNCEJAWS))[
         OUTPUT ICM_$SYNCEJAWS, I, J;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'In field ',I4,' XP(',I4,') beyond RMAX_CM'//);
         IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       IF(ABS(DXP_$SYNCEJAWS(K) - RAD_$SYNCEJAWS(J))>RMAX_CM(ICM_$SYNCEJAWS))[
          OUTPUT ICM_$SYNCEJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'In field ',I4,' XP(',I4,') - RAD beyond RMAX_CM'//);
          IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       IF(ABS(DXN_$SYNCEJAWS(K) + RAD_$SYNCEJAWS(J))>RMAX_CM(ICM_$SYNCEJAWS))[
          OUTPUT ICM_$SYNCEJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'In field ',I4,' XN(',I4,') + RAD beyond RMAX_CM'//);
          IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       IF((DXP_$SYNCEJAWS(K) - RAD_$SYNCEJAWS(J)) < (DXN_$SYNCEJAWS(K)
                                                    + RAD_$SYNCEJAWS(J)))[
          OUTPUT ICM_$SYNCEJAWS,I, J, J;
        (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
           'In field ',I4,' XP(',I4,') < XN(',I4,')'//);
          IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
       ]
       ELSEIF((DXP_$SYNCEJAWS(K) - RAD_$SYNCEJAWS(J))
              - (DXN_$SYNCEJAWS(K) + RAD_$SYNCEJAWS(J)) < $BDY_TOL*3 )[
          DXP_$SYNCEJAWS(K) = DXP_$SYNCEJAWS(K) + $BDY_TOL*2;
          DXN_$SYNCEJAWS(K) = DXN_$SYNCEJAWS(K) - $BDY_TOL*2;
       ]
     ]
  ]
  CLOSE(UNIT=jaws_unit);

  OUTPUT;('******JAWS SEQUENCE FILE READ******');
  IF (MODE_$SYNCEJAWS=1) [
      OUTPUT; ('**dynamic delivery**');
  ]
  ELSEIF (MODE_$SYNCEJAWS=2) [
      OUTPUT; ('**step and shoot delivery**');
  ]
]

"set absolute region number to first region in CM for next set of inputs"
IRA = IRSTART_$SYNCEJAWS; "absolute region number"
OUTPUT ; (/'  Now input data re ECUT and PCUT for each region'/
         /' For central region which is assumed to be air'
         /' ECUT,       PCUT,   DOSE ZONE OF AIR,   REGION TO BIT '/' : ',$);
MINPUT ($SYNCEJAWS) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
        (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA); (2F11.5,2I5);
IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
"get material for each bar and determine material number for these regions
MED(IRA) = AIR_INDEX; " medium of air
"
"now get info on each set of jaws"
DO IR_$SYNCEJAWS = 2, N_$SYNCEJAWS-1, 3[
   IRA = IRSTART_$SYNCEJAWS  + IR_$SYNCEJAWS - 1;"this is absolute region number"
   "central region air, so pick up same parameters as assigned above"
   "this is redundant on first time thru loop"
   ECUT(IRA-1) = ECUT(IRSTART_$SYNCEJAWS);
   PCUT(IRA-1) = PCUT(IRSTART_$SYNCEJAWS);
   DOSE_ZONE(IRA-1) = DOSE_ZONE(IRSTART_$SYNCEJAWS);
   MED(IRA-1) = AIR_INDEX; " medium of air
   OUTPUT IR_$SYNCEJAWS/3 + 1 ; (/' Paired bars/jaws no:',I3,
         /' ECUT,        PCUT,       DOSE ZONE,    IREGION_TO_BIT '/' :',$);
  ;MINPUT ($SYNCEJAWS) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F15.0,2I5);
  ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F11.5,2I5);
   IREGION_TO_BIT(IRA -1) = IREGION_TO_BIT(IRSTART_$SYNCEJAWS);
   IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
   "get material for each bar and determine material number for these regions
   OUTPUT;(' Medium in this region',$);
   $MED_INPUT($SYNCEJAWS); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
      "error transfers to :ERROR_$SYNCEJAWS:
   MED(IRA) = MED_INDEX; " medium of the planar slab
   "both parts of jaw are same material so transfer parameters"
   ECUT(IRA+1) = ECUT(IRA);
   PCUT(IRA+1) = PCUT(IRA);
   DOSE_ZONE(IRA+1) = DOSE_ZONE(IRA);
   IREGION_TO_BIT(IRA +1) = IREGION_TO_BIT(IRA);
   MED(IRA+1) = MED(IRA); "
] "end of loop over IR_$SYNCEJAWS"
;
"  set up region numbers
"  =====================
"
"  CM has 4xISCM_MAX_$SYNCEJAWS regions, series of paired bars/jaws surrounded
"  by an air region.  paired bars are numbered in sequence starting from the
"  furthest upstream.
"
IREND_$SYNCEJAWS = IRSTART_$SYNCEJAWS + N_$SYNCEJAWS-1;  "Index of last region
NREG = NREG+N_$SYNCEJAWS;           "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_$SYNCEJAWS+1) = IREND_$SYNCEJAWS+1;
]
ELSE [
      OUTPUT ICM_$SYNCEJAWS,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (SYNCEJAWS):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_$SYNCEJAWS)=IERR_GEOM(ICM_$SYNCEJAWS)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates
"
"
IF(MODE_$SYNCEJAWS=0)[
DO I = 1, ISCM_MAX_$SYNCEJAWS[
   ROUNDMIN_$SYNCEJAWS(I) = RAD_$SYNCEJAWS(I) -
                              SQRT(RAD_$SYNCEJAWS(I) * RAD_$SYNCEJAWS(I) -
                              (ZMIN_$SYNCEJAWS(I) - ZRAD_$SYNCEJAWS(I))
                              * (ZMIN_$SYNCEJAWS(I) - ZRAD_$SYNCEJAWS(I)));
   ROUNDMAX_$SYNCEJAWS(I) = RAD_$SYNCEJAWS(I) -
                              SQRT(RAD_$SYNCEJAWS(I) * RAD_$SYNCEJAWS(I) -
                              (ZMAX_$SYNCEJAWS(I) - ZRAD_$SYNCEJAWS(I))
                              * (ZMAX_$SYNCEJAWS(I) - ZRAD_$SYNCEJAWS(I)));
]

BDYTOL = $BDY_TOL;
DO I = 1,ISCM_MAX_$SYNCEJAWS ["loop through bars"
  XPT_$SYNCEJAWS(I,1) = XP_$SYNCEJAWS(I) + BDYTOL;
  XPT_$SYNCEJAWS(I,2) = XP_$SYNCEJAWS(I) - BDYTOL;
  XNT_$SYNCEJAWS(I,1) = XN_$SYNCEJAWS(I) + BDYTOL;
  XNT_$SYNCEJAWS(I,2) = XN_$SYNCEJAWS(I) - BDYTOL;
] "end of loop over I"

]
"
"establish start of next CM
IF(MODE_$SYNCEJAWS=0)[
Z_min_CM(ICM_$SYNCEJAWS+1) = ZMAX_$SYNCEJAWS(ISCM_MAX_$SYNCEJAWS);
]
ELSE[
Z_min_CM(ICM_$SYNCEJAWS+1) = TZMAX;
]
"
"
ZFRONT_$SYNCEJAWS = Z_min_CM(ICM_$SYNCEJAWS);
ZBACK_$SYNCEJAWS = Z_min_CM(ICM_$SYNCEJAWS+1);
"
"  establish CM boundary is a square
"  =================================
"
RMAX_CM_FLAG(ICM_$SYNCEJAWS) = 2; "=> put a square boundary about CM

"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_$SYNCEJAWS-1; "absolute region number
DO IR_$SYNCEJAWS=1,N_$SYNCEJAWS ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones and latch
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);

   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_$SYNCEJAWS
E_min_out(ICM_$SYNCEJAWS)=ECUT(IRA); "Minimum energy on exit from CM


"   return from INPUT_SYNCEJAWS
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_$SYNCEJAWS:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_$SYNCEJAWS:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

:no-jaws-data-file:
;OUTPUT;(//' *** ERROR: SYNCEJAWS position data file could not be opened');
STOP;
END;  "End of INPUT_$SYNCEJAWS"
%E   "Start of subroutine ISUMRY_$SYNCEJAWS "
"*******************************************************************************
"
"                          Subroutine ISUMRY_SYNCEJAWS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_$SYNCEJAWS;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_$SYNCEJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SYNCEJAWS
"T>**********************************
"T>

INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IRA,       "T>absolute region number
   I,J;       "T>DO loop index

$REAL
   XYMAX,     "T>X or Y boundary
   VOLAIR_$SYNCEJAWS,  "T>air volume
   VOL_$SYNCEJAWS($MAX_N_$SYNCEJAWS); "T>volume of air between bar
CHARACTER*1 XY_CHOICE(1);

"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$SYNCEJAWS.
"
IRA = IRSTART_$SYNCEJAWS-2; "absolute region number
VOLAIR_$SYNCEJAWS=(ZBACK_$SYNCEJAWS-ZFRONT_$SYNCEJAWS)*
            4.*RMAX_CM2(ICM_$SYNCEJAWS);"air volume"
DO I = 1,ISCM_MAX_$SYNCEJAWS [
  IRA=IRA+3;
   VOL_$SYNCEJAWS(I)=(ZMAX_$SYNCEJAWS(I)-ZMIN_$SYNCEJAWS(I))*
               (4.*RMAX_CM2(ICM_$SYNCEJAWS));
   VOLAIR_$SYNCEJAWS=VOLAIR_$SYNCEJAWS-VOL_$SYNCEJAWS(I);
   IF(DOSE_ZONE(IRA)~=0) [ "this is a dose zone"
      ID=DOSE_ZONE(IRA);
     AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOL_$SYNCEJAWS(I);
   ]
] "end of loop over IR_$SYNCEJAWS"
IRA = IRSTART_$SYNCEJAWS; "absolute region number
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_$SYNCEJAWS;
]


"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_$SYNCEJAWS,TITLE_$SYNCEJAWS;
WRITE(IOUTLIST,120) Z_min_CM(ICM_$SYNCEJAWS),RMAX_CM(ICM_$SYNCEJAWS);
WRITE(IOUTLIST,122);
DO I=1, ISCM_MAX_$SYNCEJAWS[
   IF(I=1)[
        WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_$SYNCEJAWS),ZMIN_$SYNCEJAWS(1)-
                           Z_min_CM(ICM_$SYNCEJAWS),'NA','NA','NA','NA',
                           'NA';
   ]
   ELSE[
        WRITE(IOUTLIST,124)'airgap',ZMAX_$SYNCEJAWS(I-1),ZMIN_$SYNCEJAWS(I)-
                           ZMAX_$SYNCEJAWS(I-1),'NA','NA','NA','NA',
                           'NA';
   ]
   IF(IXY_CHOICE_$SYNCEJAWS(I) = 0)[XY_CHOICE(1) ='x';]
   ELSE[XY_CHOICE(1) ='y';]
   WRITE(IOUTLIST,123)I,ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I)-
                      ZMIN_$SYNCEJAWS(I),XY_CHOICE(1),
                      XP_$SYNCEJAWS(I),XN_$SYNCEJAWS(I);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_$SYNCEJAWS-1;
DO I = 1, ISCM_MAX_$SYNCEJAWS [
   IRA = IRSTART_$SYNCEJAWS + 3*(I-1);
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+2)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
   ]
   WRITE(IOUTLIST,141)' ';
]
110 FORMAT(///1X,79('-')/
'  Component module',I3,' is SYNCEJAWS '
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'$SYNCEJAWS geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'jaw #    Z front    thickness    x or y               coordinates',
/T2,
'          face                   jaws        FP       BP       FN',
'      BN',
/T2,
'          (cm)        (cm)                                (cm)');
123 FORMAT(T2,I3,F12.3,F11.3,9X,A1,F12.3,F9.3,F9.3,F9.3);
124 FORMAT(T2,A6,F9.3,F11.3,8X,A2,A11,A9,A9,A8);
130 FORMAT(/T2,'$SYNCEJAWS region parameters:',
           /T2,'---------------------------',
           /T2,'local jaw #   location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
141 FORMAT(15X,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO I =1,ISCM_MAX_$SYNCEJAWS["Loop over local region number"
      XYMAX = RMAX_CM(ICM_$SYNCEJAWS);
         IF(IXY_CHOICE_$SYNCEJAWS(I) = 0)[
            WRITE(IOUTGEOM,200)
             ICOLOUR,'COLX',XYMAX,XP_$SYNCEJAWS(I),XYMAX,XYMAX,
               ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I);
            WRITE(IOUTGEOM,200)
              ICOLOUR,'COLX',XN_$SYNCEJAWS(I),-XYMAX,-XYMAX,
              XYMAX, ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I);
         ]
         ELSEIF(IXY_CHOICE_$SYNCEJAWS(I) = 1)[
            J = ICOLOUR-1;
            IF(J < 1)[J = 4;]
            WRITE(IOUTGEOM,200)
               J,'COLY',XYMAX,XP_$SYNCEJAWS(I),XYMAX,XYMAX,
               ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I);
            WRITE(IOUTGEOM,200)
               J,'COLY',XN_$SYNCEJAWS(I),-XYMAX,-XYMAX,XYMAX,
               ZMIN_$SYNCEJAWS(I),ZMAX_$SYNCEJAWS(I);
         ]
   ]
] "End of graphics output"

200 FORMAT(' ',I1,A4,10(F7.2,','));

"   end of ISUMRY_SYNCEJAWS
"   ===================
"
RETURN;
END;  "End of subroutine ISUMRY_$SYNCEJAWS"

%E   "Start of subroutine HOWNEAR_$SYNCEJAWS "
"******************************************************************************
"
"                          Subroutine HOWNEAR_SYNCEJAWS
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Replaces the old HOWNEAR macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_$SYNCEJAWS(DIST);


$IMPLICIT-NONE;

COMIN/CM_$SYNCEJAWS,STACK,USER/;

$REAL DIST, "T> min. distance to nearest boundary
      RPERP_$SYNCEJAWS;

IR_$SYNCEJAWS = IR(NP)-IRSTART_$SYNCEJAWS+1;
ISCM_$SYNCEJAWS = (IR_$SYNCEJAWS-1)/3 + 1;
XY_$SYNCEJAWS = X(NP);
UV_$SYNCEJAWS = U(NP);
IF(IXY_CHOICE_$SYNCEJAWS(ISCM_$SYNCEJAWS) = 1)[
   XY_$SYNCEJAWS = Y(NP);
   UV_$SYNCEJAWS = V(NP);
]
IF(IR_$SYNCEJAWS = 3*ISCM_$SYNCEJAWS-1) [ "particle in positive bars"

  RPERP_$SYNCEJAWS = SQRT((Z(NP) - ZRAD_$SYNCEJAWS(ISCM_$SYNCEJAWS))
                      * (Z(NP) - ZRAD_$SYNCEJAWS(ISCM_$SYNCEJAWS))
                     + (XY_$SYNCEJAWS - XPT_$SYNCEJAWS(ISCM_$SYNCEJAWS,2))
                      * (XY_$SYNCEJAWS - XPT_$SYNCEJAWS(ISCM_$SYNCEJAWS,2)));

  IF (XY_$SYNCEJAWS > XP_$SYNCEJAWS(ISCM_$SYNCEJAWS)) [
    DIST = RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RPERP_$SYNCEJAWS;
  ]
  ELSE [
    DIST = RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RPERP_$SYNCEJAWS;
  ]

  DIST = MIN(DIST,
             ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) - Z(NP),
             Z(NP) - ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS));
]
ELSEIF(IR_$SYNCEJAWS = 3*ISCM_$SYNCEJAWS) [ "particle in negative bars"
  RPERP_$SYNCEJAWS = SQRT((Z(NP) - ZRAD_$SYNCEJAWS(ISCM_$SYNCEJAWS))
                      * (Z(NP) - ZRAD_$SYNCEJAWS(ISCM_$SYNCEJAWS))
                     + (XY_$SYNCEJAWS - XNT_$SYNCEJAWS(ISCM_$SYNCEJAWS,2))
                      * (XY_$SYNCEJAWS - XNT_$SYNCEJAWS(ISCM_$SYNCEJAWS,2)));

  IF (XY_$SYNCEJAWS < XN_$SYNCEJAWS(ISCM_$SYNCEJAWS)) [
    DIST = RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS) + RPERP_$SYNCEJAWS;
  ]
  ELSE [
    DIST = RAD_$SYNCEJAWS(ISCM_$SYNCEJAWS) - RPERP_$SYNCEJAWS;
  ]

  DIST = MIN(DIST,
             ZMAX_$SYNCEJAWS(ISCM_$SYNCEJAWS) - Z(NP),
             Z(NP) - ZMIN_$SYNCEJAWS(ISCM_$SYNCEJAWS));
]
ELSE[ "particle in air"
   DIST = 0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_$SYNCEJAWS "
"*******************************************************************************
"End of SYNCEJAWS_cm.mortran "
